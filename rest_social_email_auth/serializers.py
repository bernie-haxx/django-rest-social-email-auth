# DRF Packages
from rest_framework import serializers
from rest_framework.validators import UniqueValidator

# Installed Packages
from rest_social_auth.serializers import UserKnoxSerializer

# Django Packages
from django.contrib.auth import get_user_model, password_validation
from django.utils.translation import gettext_lazy as __

# Local Packages
from rest_social_email_auth import (
		signals,
		models
)


class CreateUserSerializer(serializers.ModelSerializer):
	email = serializers.EmailField(
		required=True,
		validators=[UniqueValidator(queryset=get_user_model().objects.all())]
	)
	username = serializers.CharField(
		required=True,
		max_length=13,
		validators=[UniqueValidator(queryset=get_user_model().objects.all())]
	)
	password = serializers.CharField(
		min_length=8,
		write_only=True
	)

	def create(self, validated_data):
		account = get_user_model().objects.create_user(
			username=validated_data['username'],
			email=validated_data['email'],
			password=validated_data['password']
		)

		signals.user_registered.send(
				sender=self.__class__,
				user=account
			)
		return account

	def validate_email(self, email):
		"""
		Validate the provided email address.

		Args:
			email:
				The email address to validate.

		Returns:
			The provided email address, transformed to match the RFC
			spec. Namely, the domain portion of the email must be 
			lowercase.
			# Sowy for the formality onnichan or ani-wee its for the best.
		"""
		user, domain = email.rsplit("@", 1)
		email = "@".join([user, domain.lower()])

		if self.instance and email and self.instance.email != email:
			raise serializers.ValidationError(
				__(
					"Existing emails may not be edited. Create a new one "
					"instead."
				)

			)

		return email

	def validate_password(self, password):
		"""
		Validate the provided password.


		Args:
			password (str):
				The password provided by the user.

		Returns:
			str:
				The validated password.

		Raises:
			ValidationError:
				If the provided password does not pass the
				considered password validators.
		"""

		password_validation.validate_password(password)

		return password

	class Meta(object):
		model = get_user_model()
		fields = ('id', 'username', 'email', 'password')

class EmailSerializer(serializers.ModelSerializer):
	"""
	Serializer for email addresses
	"""

	class Meta(object):
		extra_kwargs = {
			"email": {
				# We remove the autogenerated 'unique' validator to
				# avoid leaking email addresses
				"validators": []
			}
		}
		fields =("id", "created_at", "email", "is_primary", "is_verified")
		model = models.EmailAddress
		read_only_fields = ("is_verified",)


	def create(self, validated_data):
		"""
		Create a new email and send a confirmation to it.

		Returns:
			The newly creating ``EmailAddress`` instance.
		"""
		email_query = models.EmailAddress.objects.filter(
			email=self.validated_data["email"]
		)

		if email_query.exists():
			email = email_query.get()

			email.send_duplicate_notification()
		else:
				email = super(EmailSerializer, self).create(validated_data)
				# email.send_confirmation()

				user = validated_data.get("user")
				query = models.EmailAddress.objects.filter(
					is_primary=True, user=user
				)

				if not query.exists():
					email.set_primary()

		return email

	def update(self, instance , validated_data):
		"""
		Update the instance the serializer is bound to.


		Args:
			instance:
				The instance the serializer is bound to.
			validated_data:
				The data to update the serializer with.

		Returns:
			The updated instance.
		"""
		is_primary = validated_data.pop("is_primary", False)

		instance = super(EmailSerializer, self).update(
			instance, validated_data
		)

		if is_primary:
			instance.set_primary()

		return instance

	def validate_email(self, email):
		"""
		Validate the provided email address.

		The email address is first modified to match the RFC spec.
		Namely, the domain portion of the email is lowercased.

		Returns:
			The validated email address.

		Raises:
			serializers.ValidationError:
				If the serializer is bound and the provided email
				doesn't match the existong email address.
		"""
		user, domain = email.rsplit("@", 1)
		email = "@".join([user, domain.lower()])

		if self.instance and email and self.instance.email != email:
			raise serializers.ValidationError(
				__(
					"Existing emails may not be edited. Create a new one "
					"instead."
				)
			)

		return email

	def validate_is_primary(self, is_primary):
		"""
		Validate the provided 'is_primary' parameter.

		Returns:
			The validated 'is_primary' value.

		Raises:
			serializers.ValidationError:
				If the user attempted to mark an unverified email as their primary email address.        
		"""

		# TODO: Setting is_primary to 'False' should probably not be allowed.
		if is_primary and not (self.instance and self.instance.is_verified):
			raise serializers.ValidationError(
				__(
					"Unverified email addresses may not be used as the "
					"primary address."
				)
			)
		return is_primary

class AccountSerializer(serializers.ModelSerializer):
	class Meta:
		model = get_user_model()
		fields = ('id', 'last_login', 'is_superuser', 'username', 'email', 'phone_number', 'is_active')


# Social Logins serializer
class SocialSerializer(UserKnoxSerializer):
	def get_token(self, obj):
		instance, token = models.AuthToken.objects.create(obj)
		instance.save()
		return token